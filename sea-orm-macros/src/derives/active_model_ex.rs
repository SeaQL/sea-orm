use super::active_model::DeriveActiveModel;
use super::util::{extract_compound_entity, field_not_ignored_compound, is_compound_field};
use proc_macro2::{Ident, TokenStream};
use quote::quote;
use syn::{Data, Fields, Type};

pub fn expand_derive_active_model_ex(ident: &Ident, data: &Data) -> syn::Result<TokenStream> {
    let mut model_fields = Vec::new();
    let mut field_types: Vec<Type> = Vec::new();
    let mut scalar_fields = Vec::new();
    let mut compound_fields = Vec::new();

    if let Data::Struct(item_struct) = &data {
        if let Fields::Named(fields) = &item_struct.fields {
            for field in fields
                .named
                .iter()
                .filter(|f| field_not_ignored_compound(f))
            {
                if let Some(ident) = &field.ident {
                    let field_type = &field.ty;
                    let field_type = quote! { #field_type }
                        .to_string() // e.g.: "Option < String >"
                        .replace(' ', ""); // Remove spaces

                    let ty = if is_compound_field(&field_type) {
                        compound_fields.push(ident);
                        let entity_path = extract_compound_entity(&field_type);
                        if field_type.starts_with("HasOne<") {
                            syn::parse_str(&format!("HasOneModel < {entity_path} >"))?
                        } else {
                            syn::parse_str(&format!("HasManyModel < {entity_path} >"))?
                        }
                    } else {
                        scalar_fields.push(ident);
                        syn::parse_str(&format!("sea_orm::ActiveValue < {field_type} >"))?
                    };
                    model_fields.push(ident);
                    field_types.push(ty);
                }
            }
        }
    }

    let active_model_trait_methods =
        DeriveActiveModel::new(ident, data)?.impl_active_model_trait_methods();

    Ok(quote! {
        #[doc = " Generated by sea-orm-macros"]
        #[derive(Clone, Debug, PartialEq)]
        pub struct ActiveModelEx {
            #(
                #[doc = " Generated by sea-orm-macros"]
                pub #model_fields: #field_types
            ),*
        }

        impl ActiveModel {
            #[doc = " Generated by sea-orm-macros"]
            pub fn into_ex(self) -> ActiveModelEx {
                self.into()
            }
        }

        #[automatically_derived]
        impl sea_orm::ActiveModelTrait for ActiveModelEx {
            type Entity = Entity;

            #active_model_trait_methods

            fn default() -> Self {
                Self {
                    #(#scalar_fields: Default::default(),)*
                    #(#compound_fields: Default::default(),)*
                }
            }
        }

        #[automatically_derived]
        impl std::default::Default for ActiveModelEx {
            fn default() -> Self {
                <ActiveModel as sea_orm::ActiveModelBehavior>::new().into()
            }
        }

        #[automatically_derived]
        impl std::convert::From<ActiveModel> for ActiveModelEx {
            fn from(m: ActiveModel) -> Self {
                Self {
                    #(#scalar_fields: m.#scalar_fields,)*
                    #(#compound_fields: Default::default(),)*
                }
            }
        }

        #[automatically_derived]
        impl std::convert::From<ModelEx> for ActiveModelEx {
            fn from(m: ModelEx) -> Self {
                Self {
                    #(#scalar_fields: sea_orm::ActiveValue::Unchanged(m.#scalar_fields),)*
                    #(#compound_fields: m.#compound_fields.into_active_model(),)*
                }
            }
        }

        #[automatically_derived]
        impl sea_orm::IntoActiveModel<ActiveModelEx> for ModelEx {
            fn into_active_model(self) -> ActiveModelEx {
                self.into()
            }
        }
    })
}
