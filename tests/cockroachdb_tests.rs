#![allow(unused_imports, dead_code)]

pub mod common;

pub use sea_orm::{ConnectionTrait, DbBackend, DbErr};

// DATABASE_URL=cockroachdb://...:26257/... cargo test --features cockroachdb,sqlx-postgres,runtime-tokio --test cockroachdb_tests
#[sea_orm_macros::test]
#[cfg(feature = "cockroachdb")]
async fn test_cockroachdb_backend_detection() -> Result<(), DbErr> {
    // Test is_prefix_of for various URL schemes
    assert!(DbBackend::Cockroach.is_prefix_of("cockroachdb://localhost:26257/test"));
    assert!(DbBackend::Cockroach.is_prefix_of("postgres://localhost:26257/test"));
    assert!(DbBackend::Cockroach.is_prefix_of("postgresql://localhost:26257/test"));
    assert!(!DbBackend::Cockroach.is_prefix_of("mysql://localhost:3306/test"));
    assert!(!DbBackend::Cockroach.is_prefix_of("sqlite://test.db"));

    // Test as_str
    assert_eq!(DbBackend::Cockroach.as_str(), "Cockroach");

    // Test support_returning
    assert!(DbBackend::Cockroach.support_returning());

    Ok(())
}

#[sea_orm_macros::test]
#[cfg(feature = "cockroachdb")]
async fn test_cockroachdb_statement_building() -> Result<(), DbErr> {
    use sea_orm::sea_query::{Query, Alias, MysqlQueryBuilder, PostgresQueryBuilder};

    // Test that CockroachDB uses Postgres query builder
    let select = Query::select()
        .column(Alias::new("id"))
        .from(Alias::new("test"))
        .to_owned();

    let stmt = DbBackend::Cockroach.build(&select);
    assert_eq!(stmt.db_backend, DbBackend::Cockroach);

    // The SQL should be PostgreSQL compatible
    let sql = stmt.sql;
    assert!(sql.contains("SELECT"));
    assert!(sql.contains("FROM"));

    // Verify it uses PostgreSQL-style placeholders, not MySQL-style
    let mysql_sql = select.to_string(MysqlQueryBuilder);
    let postgres_sql = select.to_string(PostgresQueryBuilder);

    // The CockroachDB output should match PostgreSQL
    assert_ne!(sql, mysql_sql, "CockroachDB SQL should not match MySQL style");
    assert_eq!(sql, postgres_sql, "CockroachDB SQL should match PostgreSQL style");

    Ok(())
}

#[sea_orm_macros::test]
#[cfg(feature = "cockroachdb")]
async fn test_cockroachdb_schema_statements() -> Result<(), DbErr> {
    use sea_orm::sea_query::{Table, ColumnDef, Alias};

    // Test table create statement builds correctly
    let table = Table::create()
        .table(Alias::new("test_table"))
        .col(
            ColumnDef::new(Alias::new("id"))
                .integer()
                .not_null()
                .auto_increment()
                .primary_key(),
        )
        .col(ColumnDef::new(Alias::new("name")).string())
        .col(ColumnDef::new(Alias::new("active")).boolean())
        .to_owned();

    let stmt = DbBackend::Cockroach.build(&table);

    // Should use IDENTITY, not SERIAL
    assert!(
        stmt.sql.contains("GENERATED BY DEFAULT AS IDENTITY"),
        "Expected GENERATED BY DEFAULT AS IDENTITY in SQL: {}",
        stmt.sql
    );
    assert!(
        !stmt.sql.contains("SERIAL"),
        "SERIAL should not be used for CockroachDB: {}",
        stmt.sql
    );

    Ok(())
}

#[sea_orm_macros::test]
#[cfg(feature = "cockroachdb")]
async fn test_cockroachdb_schema_identity() -> Result<(), DbErr> {
    use sea_orm::sea_query::{ColumnDef, Alias, PostgresQueryBuilder, Table};

    // Create a table with auto-increment primary key
    let table = Table::create()
        .table(Alias::new("test_table"))
        .col(
            ColumnDef::new(Alias::new("id"))
                .integer()
                .not_null()
                .auto_increment()
                .primary_key(),
        )
        .col(ColumnDef::new(Alias::new("name")).string())
        .to_owned();

    // Build the SQL - should use GENERATED BY DEFAULT AS IDENTITY, not SERIAL
    let sql = table.to_string(PostgresQueryBuilder);

    // CockroachDB uses GENERATED BY DEFAULT AS IDENTITY instead of SERIAL
    assert!(
        sql.contains("GENERATED BY DEFAULT AS IDENTITY"),
        "Expected GENERATED BY DEFAULT AS IDENTITY in schema, got: {sql}"
    );
    assert!(
        !sql.contains("SERIAL"),
        "SERIAL should not be used for CockroachDB, got: {sql}"
    );

    Ok(())
}

#[sea_orm_macros::test]
#[cfg(feature = "cockroachdb")]
async fn test_cockroachdb_boolean_value() -> Result<(), DbErr> {
    use sea_orm::sea_query::Value;

    let true_val = DbBackend::Cockroach.boolean_value(true);
    let false_val = DbBackend::Cockroach.boolean_value(false);

    // Boolean values should be converted correctly
    assert_eq!(true_val, Value::Bool(Some(true)));
    assert_eq!(false_val, Value::Bool(Some(false)));

    Ok(())
}

#[test]
#[cfg(all(feature = "cockroachdb", feature = "mock"))]
fn test_cockroachdb_mock() {
    use sea_orm::MockDatabase;

    let db = MockDatabase::new(DbBackend::Cockroach).into_connection();

    assert_eq!(db.get_database_backend(), DbBackend::Cockroach);
    assert!(db.support_returning());
}

#[sea_orm_macros::test]
#[cfg(feature = "cockroachdb")]
async fn test_cockroachdb_insert_building() -> Result<(), DbErr> {
    use sea_orm::sea_query::{Query, Alias};

    // Test INSERT statement
    let insert = Query::insert()
        .into_table(Alias::new("test_table"))
        .columns([Alias::new("name"), Alias::new("value")])
        .values_panic(["test".into(), 42i32.into()])
        .to_owned();

    let stmt = DbBackend::Cockroach.build(&insert);
    assert_eq!(stmt.db_backend, DbBackend::Cockroach);
    assert!(stmt.sql.contains("INSERT"));
    assert!(stmt.sql.contains("INTO"));

    Ok(())
}
